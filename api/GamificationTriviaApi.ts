/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://demo.sandbox.knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class GamificationTriviaApi {
    protected basePath = 'https://integration.knetikcloud.com/';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Add an answer to a question
     * 
     * @param questionId The id of the question
     * @param answer The new answer
     */
    public addAnswersUsingPOST(questionId: string, answer?: models.AnswerResource, extraHttpRequestParams?: any): Observable<models.AnswerResource> {
        return this.addAnswersUsingPOSTWithHttpInfo(questionId, answer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Add a tag to a question
     * 
     * @param id The id of the question
     * @param tag The new tag
     */
    public addTagUsingPOST(id: string, tag?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.addTagUsingPOSTWithHttpInfo(id, tag, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public batchAddTagUsingPOST(tag?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.batchAddTagUsingPOSTWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public batchRemoveTagUsingDELETE(tag: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.batchRemoveTagUsingDELETEWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public bulkUpdateUsingPUT(question?: models.QuestionResource, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.bulkUpdateUsingPUTWithHttpInfo(question, filterSearch, filterIdset, filterCategory, filterTagset, filterType, filterPublished, filterImportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Count questions based on filters.
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    public countQuestionsUsingGET(filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, extraHttpRequestParams?: any): Observable<number> {
        return this.countQuestionsUsingGETWithHttpInfo(filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    public createQuestionTemplateUsingPOST(questionTemplateResource?: models.QuestionTemplateResource, extraHttpRequestParams?: any): Observable<models.QuestionTemplateResource> {
        return this.createQuestionTemplateUsingPOSTWithHttpInfo(questionTemplateResource, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create a question
     * 
     * @param question The new question
     */
    public createQuestionUsingPOST(question?: models.QuestionResource, extraHttpRequestParams?: any): Observable<models.QuestionResource> {
        return this.createQuestionUsingPOSTWithHttpInfo(question, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    public createUsingPOST(request?: models.ImportJobResource, extraHttpRequestParams?: any): Observable<models.ImportJobResource> {
        return this.createUsingPOSTWithHttpInfo(request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteQuestionTemplateUsingDELETE(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteQuestionTemplateUsingDELETEWithHttpInfo(id, cascade, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Delete a question
     * 
     * @param id The id of the question
     */
    public deleteQuestionUsingDELETE(id: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteQuestionUsingDELETEWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    public deleteUsingDELETE(id: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteUsingDELETEWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public getAnswerUsingGET(questionId: string, id: string, extraHttpRequestParams?: any): Observable<models.AnswerResource> {
        return this.getAnswerUsingGETWithHttpInfo(questionId, id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List the answers available for a question
     * 
     * @param questionId The id of the question
     */
    public getAnswersUsingGET(questionId: string, extraHttpRequestParams?: any): Observable<Array<models.AnswerResource>> {
        return this.getAnswersUsingGETWithHttpInfo(questionId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get a list of import job
     * 
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getListUsingGET1(filterVendor?: string, filterCategory?: string, filterName?: string, filterStatus?: string, size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<models.PageResourceImportJobResource> {
        return this.getListUsingGET1WithHttpInfo(filterVendor, filterCategory, filterName, filterStatus, size, page, order, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get a single question template
     * 
     * @param id The id of the template
     */
    public getQuestionTemplateUsingGET(id: string, extraHttpRequestParams?: any): Observable<models.QuestionTemplateResource> {
        return this.getQuestionTemplateUsingGETWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List and search question templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getQuestionTemplatesUsingGET(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<models.PageResourceQuestionTemplateResource> {
        return this.getQuestionTemplatesUsingGETWithHttpInfo(size, page, order, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get a single question
     * 
     * @param id The id of the question
     */
    public getQuestionUsingGET(id: string, extraHttpRequestParams?: any): Observable<models.QuestionResource> {
        return this.getQuestionUsingGETWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    public getQuestionsDeltaUsingGET(since?: number, extraHttpRequestParams?: any): Observable<Array<models.DeltaResource>> {
        return this.getQuestionsDeltaUsingGETWithHttpInfo(since, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List and search questions
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public getQuestionsUsingGET(size?: number, page?: number, order?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<models.PageResourceQuestionResource> {
        return this.getQuestionsUsingGETWithHttpInfo(size, page, order, filterSearch, filterIdset, filterCategory, filterTagset, filterType, filterPublished, filterImportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List the tags for a question
     * 
     * @param id The id of the question
     */
    public getTagsUsingGET1(id: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getTagsUsingGET1WithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    public getTagsUsingGET2(filterSearch?: string, filterCategory?: string, filterImportId?: number, extraHttpRequestParams?: any): Observable<models.Collectionstring> {
        return this.getTagsUsingGET2WithHttpInfo(filterSearch, filterCategory, filterImportId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get an import job
     * 
     * @param id The id of the job
     */
    public getUsingGET(id: number, extraHttpRequestParams?: any): Observable<models.ImportJobResource> {
        return this.getUsingGETWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Remove an answer from a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public removeAnswersUsingDELETE(questionId: string, id: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.removeAnswersUsingDELETEWithHttpInfo(questionId, id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Remove a tag from a question
     * 
     * @param id The id of the question
     * @param tag The tag to remove
     */
    public removeTagUsingDELETE(id: string, tag: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.removeTagUsingDELETEWithHttpInfo(id, tag, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    public startProcessUsingPOST(id: number, publishNow: boolean, extraHttpRequestParams?: any): Observable<models.ImportJobResource> {
        return this.startProcessUsingPOSTWithHttpInfo(id, publishNow, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    public updateAnswerUsingPUT(questionId: string, id: string, answer?: models.AnswerResource, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateAnswerUsingPUTWithHttpInfo(questionId, id, answer, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update a question template
     * 
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    public updateQuestionTemplateUsingPUT(id: string, questionTemplateResource?: models.QuestionTemplateResource, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateQuestionTemplateUsingPUTWithHttpInfo(id, questionTemplateResource, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update a question
     * 
     * @param id The id of the question
     * @param question The updated question
     */
    public updateQuestionUsingPUT(id: string, question?: models.QuestionResource, extraHttpRequestParams?: any): Observable<models.QuestionResource> {
        return this.updateQuestionUsingPUTWithHttpInfo(id, question, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    public updateUsingPUT(id: number, request?: models.ImportJobResource, extraHttpRequestParams?: any): Observable<models.ImportJobResource> {
        return this.updateUsingPUTWithHttpInfo(id, request, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Add an answer to a question
     * 
     * @param questionId The id of the question
     * @param answer The new answer
     */
    public addAnswersUsingPOSTWithHttpInfo(questionId: string, answer?: models.AnswerResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${question_id}/answers`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling addAnswersUsingPOST.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: answer == null ? '' : JSON.stringify(answer), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Add a tag to a question
     * 
     * @param id The id of the question
     * @param tag The new tag
     */
    public addTagUsingPOSTWithHttpInfo(id: string, tag?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}/tags`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addTagUsingPOST.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: tag == null ? '' : JSON.stringify(tag), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Add a tag to a batch of questions
     * All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
     * @param tag The tag to add
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public batchAddTagUsingPOSTWithHttpInfo(tag?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/tags`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterIdset !== undefined) {
            if(filterIdset instanceof Date) {
                queryParameters.set('filter_idset', <any>filterIdset.d.toISOString());
            } else {
                queryParameters.set('filter_idset', <any>filterIdset);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterTag !== undefined) {
            if(filterTag instanceof Date) {
                queryParameters.set('filter_tag', <any>filterTag.d.toISOString());
            } else {
                queryParameters.set('filter_tag', <any>filterTag);
            }
        }

        if (filterTagset !== undefined) {
            if(filterTagset instanceof Date) {
                queryParameters.set('filter_tagset', <any>filterTagset.d.toISOString());
            } else {
                queryParameters.set('filter_tagset', <any>filterTagset);
            }
        }

        if (filterType !== undefined) {
            if(filterType instanceof Date) {
                queryParameters.set('filter_type', <any>filterType.d.toISOString());
            } else {
                queryParameters.set('filter_type', <any>filterType);
            }
        }

        if (filterPublished !== undefined) {
            if(filterPublished instanceof Date) {
                queryParameters.set('filter_published', <any>filterPublished.d.toISOString());
            } else {
                queryParameters.set('filter_published', <any>filterPublished);
            }
        }

        if (filterImportId !== undefined) {
            if(filterImportId instanceof Date) {
                queryParameters.set('filter_import_id', <any>filterImportId.d.toISOString());
            } else {
                queryParameters.set('filter_import_id', <any>filterImportId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: tag == null ? '' : JSON.stringify(tag), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove a tag from a batch of questions
     * ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
     * @param tag The tag to remove
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public batchRemoveTagUsingDELETEWithHttpInfo(tag: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/tags/${tag}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling batchRemoveTagUsingDELETE.');
        }
        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterIdset !== undefined) {
            if(filterIdset instanceof Date) {
                queryParameters.set('filter_idset', <any>filterIdset.d.toISOString());
            } else {
                queryParameters.set('filter_idset', <any>filterIdset);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterTag !== undefined) {
            if(filterTag instanceof Date) {
                queryParameters.set('filter_tag', <any>filterTag.d.toISOString());
            } else {
                queryParameters.set('filter_tag', <any>filterTag);
            }
        }

        if (filterTagset !== undefined) {
            if(filterTagset instanceof Date) {
                queryParameters.set('filter_tagset', <any>filterTagset.d.toISOString());
            } else {
                queryParameters.set('filter_tagset', <any>filterTagset);
            }
        }

        if (filterType !== undefined) {
            if(filterType instanceof Date) {
                queryParameters.set('filter_type', <any>filterType.d.toISOString());
            } else {
                queryParameters.set('filter_type', <any>filterType);
            }
        }

        if (filterPublished !== undefined) {
            if(filterPublished instanceof Date) {
                queryParameters.set('filter_published', <any>filterPublished.d.toISOString());
            } else {
                queryParameters.set('filter_published', <any>filterPublished);
            }
        }

        if (filterImportId !== undefined) {
            if(filterImportId instanceof Date) {
                queryParameters.set('filter_import_id', <any>filterImportId.d.toISOString());
            } else {
                queryParameters.set('filter_import_id', <any>filterImportId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Bulk update questions
     * Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
     * @param question New values for a set of question fields
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public bulkUpdateUsingPUTWithHttpInfo(question?: models.QuestionResource, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterIdset !== undefined) {
            if(filterIdset instanceof Date) {
                queryParameters.set('filter_idset', <any>filterIdset.d.toISOString());
            } else {
                queryParameters.set('filter_idset', <any>filterIdset);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterTagset !== undefined) {
            if(filterTagset instanceof Date) {
                queryParameters.set('filter_tagset', <any>filterTagset.d.toISOString());
            } else {
                queryParameters.set('filter_tagset', <any>filterTagset);
            }
        }

        if (filterType !== undefined) {
            if(filterType instanceof Date) {
                queryParameters.set('filter_type', <any>filterType.d.toISOString());
            } else {
                queryParameters.set('filter_type', <any>filterType);
            }
        }

        if (filterPublished !== undefined) {
            if(filterPublished instanceof Date) {
                queryParameters.set('filter_published', <any>filterPublished.d.toISOString());
            } else {
                queryParameters.set('filter_published', <any>filterPublished);
            }
        }

        if (filterImportId !== undefined) {
            if(filterImportId instanceof Date) {
                queryParameters.set('filter_import_id', <any>filterImportId.d.toISOString());
            } else {
                queryParameters.set('filter_import_id', <any>filterImportId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: question == null ? '' : JSON.stringify(question), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Count questions based on filters.
     * This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTag Filter for questions with specified tag
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     */
    public countQuestionsUsingGETWithHttpInfo(filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTag?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/count`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterIdset !== undefined) {
            if(filterIdset instanceof Date) {
                queryParameters.set('filter_idset', <any>filterIdset.d.toISOString());
            } else {
                queryParameters.set('filter_idset', <any>filterIdset);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterTag !== undefined) {
            if(filterTag instanceof Date) {
                queryParameters.set('filter_tag', <any>filterTag.d.toISOString());
            } else {
                queryParameters.set('filter_tag', <any>filterTag);
            }
        }

        if (filterTagset !== undefined) {
            if(filterTagset instanceof Date) {
                queryParameters.set('filter_tagset', <any>filterTagset.d.toISOString());
            } else {
                queryParameters.set('filter_tagset', <any>filterTagset);
            }
        }

        if (filterType !== undefined) {
            if(filterType instanceof Date) {
                queryParameters.set('filter_type', <any>filterType.d.toISOString());
            } else {
                queryParameters.set('filter_type', <any>filterType);
            }
        }

        if (filterPublished !== undefined) {
            if(filterPublished instanceof Date) {
                queryParameters.set('filter_published', <any>filterPublished.d.toISOString());
            } else {
                queryParameters.set('filter_published', <any>filterPublished);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a question template
     * Question templates define a type of question and the properties they have
     * @param questionTemplateResource The question template resource object
     */
    public createQuestionTemplateUsingPOSTWithHttpInfo(questionTemplateResource?: models.QuestionTemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/templates`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: questionTemplateResource == null ? '' : JSON.stringify(questionTemplateResource), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a question
     * 
     * @param question The new question
     */
    public createQuestionUsingPOSTWithHttpInfo(question?: models.QuestionResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: question == null ? '' : JSON.stringify(question), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an import job
     * Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
     * @param request The new import job
     */
    public createUsingPOSTWithHttpInfo(request?: models.ImportJobResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete a question template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteQuestionTemplateUsingDELETEWithHttpInfo(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/templates/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionTemplateUsingDELETE.');
        }
        if (cascade !== undefined) {
            if(cascade instanceof Date) {
                queryParameters.set('cascade', <any>cascade.d.toISOString());
            } else {
                queryParameters.set('cascade', <any>cascade);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete a question
     * 
     * @param id The id of the question
     */
    public deleteQuestionUsingDELETEWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteQuestionUsingDELETE.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete an import job
     * Also deletes all questions that were imported by it
     * @param id The id of the job
     */
    public deleteUsingDELETEWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteUsingDELETE.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public getAnswerUsingGETWithHttpInfo(questionId: string, id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${question_id}/answers/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getAnswerUsingGET.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAnswerUsingGET.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List the answers available for a question
     * 
     * @param questionId The id of the question
     */
    public getAnswersUsingGETWithHttpInfo(questionId: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${question_id}/answers`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling getAnswersUsingGET.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a list of import job
     * 
     * @param filterVendor Filter for jobs by vendor id
     * @param filterCategory Filter for jobs by category id
     * @param filterName Filter for jobs which name *STARTS* with the given string
     * @param filterStatus Filter for jobs that are in a specific set of statuses (comma separated)
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getListUsingGET1WithHttpInfo(filterVendor?: string, filterCategory?: string, filterName?: string, filterStatus?: string, size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterVendor !== undefined) {
            if(filterVendor instanceof Date) {
                queryParameters.set('filter_vendor', <any>filterVendor.d.toISOString());
            } else {
                queryParameters.set('filter_vendor', <any>filterVendor);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterName !== undefined) {
            if(filterName instanceof Date) {
                queryParameters.set('filter_name', <any>filterName.d.toISOString());
            } else {
                queryParameters.set('filter_name', <any>filterName);
            }
        }

        if (filterStatus !== undefined) {
            if(filterStatus instanceof Date) {
                queryParameters.set('filter_status', <any>filterStatus.d.toISOString());
            } else {
                queryParameters.set('filter_status', <any>filterStatus);
            }
        }

        if (size !== undefined) {
            if(size instanceof Date) {
                queryParameters.set('size', <any>size.d.toISOString());
            } else {
                queryParameters.set('size', <any>size);
            }
        }

        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('page', <any>page.d.toISOString());
            } else {
                queryParameters.set('page', <any>page);
            }
        }

        if (order !== undefined) {
            if(order instanceof Date) {
                queryParameters.set('order', <any>order.d.toISOString());
            } else {
                queryParameters.set('order', <any>order);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single question template
     * 
     * @param id The id of the template
     */
    public getQuestionTemplateUsingGETWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/templates/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionTemplateUsingGET.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search question templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getQuestionTemplatesUsingGETWithHttpInfo(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/templates`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (size !== undefined) {
            if(size instanceof Date) {
                queryParameters.set('size', <any>size.d.toISOString());
            } else {
                queryParameters.set('size', <any>size);
            }
        }

        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('page', <any>page.d.toISOString());
            } else {
                queryParameters.set('page', <any>page);
            }
        }

        if (order !== undefined) {
            if(order instanceof Date) {
                queryParameters.set('order', <any>order.d.toISOString());
            } else {
                queryParameters.set('order', <any>order);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single question
     * 
     * @param id The id of the question
     */
    public getQuestionUsingGETWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getQuestionUsingGET.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List question deltas in ascending order of updated date
     * The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
     * @param since Timestamp in seconds
     */
    public getQuestionsDeltaUsingGETWithHttpInfo(since?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/delta`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (since !== undefined) {
            if(since instanceof Date) {
                queryParameters.set('since', <any>since.d.toISOString());
            } else {
                queryParameters.set('since', <any>since);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search questions
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterSearch Filter for documents whose question, answers or tags contains provided string
     * @param filterIdset Filter for documents whose id is in the comma separated list provided
     * @param filterCategory Filter for questions with specified category, by id
     * @param filterTagset Filter for questions with specified tags (separated by comma)
     * @param filterType Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;)
     * @param filterPublished Filter for questions currenctly published or not
     * @param filterImportId Filter for questions from a specific import job
     */
    public getQuestionsUsingGETWithHttpInfo(size?: number, page?: number, order?: string, filterSearch?: string, filterIdset?: string, filterCategory?: string, filterTagset?: string, filterType?: string, filterPublished?: boolean, filterImportId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (size !== undefined) {
            if(size instanceof Date) {
                queryParameters.set('size', <any>size.d.toISOString());
            } else {
                queryParameters.set('size', <any>size);
            }
        }

        if (page !== undefined) {
            if(page instanceof Date) {
                queryParameters.set('page', <any>page.d.toISOString());
            } else {
                queryParameters.set('page', <any>page);
            }
        }

        if (order !== undefined) {
            if(order instanceof Date) {
                queryParameters.set('order', <any>order.d.toISOString());
            } else {
                queryParameters.set('order', <any>order);
            }
        }

        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterIdset !== undefined) {
            if(filterIdset instanceof Date) {
                queryParameters.set('filter_idset', <any>filterIdset.d.toISOString());
            } else {
                queryParameters.set('filter_idset', <any>filterIdset);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterTagset !== undefined) {
            if(filterTagset instanceof Date) {
                queryParameters.set('filter_tagset', <any>filterTagset.d.toISOString());
            } else {
                queryParameters.set('filter_tagset', <any>filterTagset);
            }
        }

        if (filterType !== undefined) {
            if(filterType instanceof Date) {
                queryParameters.set('filter_type', <any>filterType.d.toISOString());
            } else {
                queryParameters.set('filter_type', <any>filterType);
            }
        }

        if (filterPublished !== undefined) {
            if(filterPublished instanceof Date) {
                queryParameters.set('filter_published', <any>filterPublished.d.toISOString());
            } else {
                queryParameters.set('filter_published', <any>filterPublished);
            }
        }

        if (filterImportId !== undefined) {
            if(filterImportId instanceof Date) {
                queryParameters.set('filter_import_id', <any>filterImportId.d.toISOString());
            } else {
                queryParameters.set('filter_import_id', <any>filterImportId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List the tags for a question
     * 
     * @param id The id of the question
     */
    public getTagsUsingGET1WithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}/tags`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTagsUsingGET1.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search tags by the beginning of the string
     * For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
     * @param filterSearch Filter for tags starting with the given text
     * @param filterCategory Filter for tags on questions from a specific category
     * @param filterImportId Filter for tags on questions from a specific import job
     */
    public getTagsUsingGET2WithHttpInfo(filterSearch?: string, filterCategory?: string, filterImportId?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/tags`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterSearch !== undefined) {
            if(filterSearch instanceof Date) {
                queryParameters.set('filter_search', <any>filterSearch.d.toISOString());
            } else {
                queryParameters.set('filter_search', <any>filterSearch);
            }
        }

        if (filterCategory !== undefined) {
            if(filterCategory instanceof Date) {
                queryParameters.set('filter_category', <any>filterCategory.d.toISOString());
            } else {
                queryParameters.set('filter_category', <any>filterCategory);
            }
        }

        if (filterImportId !== undefined) {
            if(filterImportId instanceof Date) {
                queryParameters.set('filter_import_id', <any>filterImportId.d.toISOString());
            } else {
                queryParameters.set('filter_import_id', <any>filterImportId);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get an import job
     * 
     * @param id The id of the job
     */
    public getUsingGETWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUsingGET.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove an answer from a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     */
    public removeAnswersUsingDELETEWithHttpInfo(questionId: string, id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${question_id}/answers/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling removeAnswersUsingDELETE.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeAnswersUsingDELETE.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove a tag from a question
     * 
     * @param id The id of the question
     * @param tag The tag to remove
     */
    public removeTagUsingDELETEWithHttpInfo(id: string, tag: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}/tags/${tag}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeTagUsingDELETE.');
        }
        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeTagUsingDELETE.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Start processing an import job
     * Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
     * @param id The id of the job
     * @param publishNow Whether the new questions should be published live immediately
     */
    public startProcessUsingPOSTWithHttpInfo(id: number, publishNow: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import/${id}/process`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling startProcessUsingPOST.');
        }
        // verify required parameter 'publishNow' is not null or undefined
        if (publishNow === null || publishNow === undefined) {
            throw new Error('Required parameter publishNow was null or undefined when calling startProcessUsingPOST.');
        }
        if (publishNow !== undefined) {
            if(publishNow instanceof Date) {
                queryParameters.set('publish_now', <any>publishNow.d.toISOString());
            } else {
                queryParameters.set('publish_now', <any>publishNow);
            }
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an answer for a question
     * 
     * @param questionId The id of the question
     * @param id The id of the answer
     * @param answer The updated answer
     */
    public updateAnswerUsingPUTWithHttpInfo(questionId: string, id: string, answer?: models.AnswerResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${question_id}/answers/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling updateAnswerUsingPUT.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAnswerUsingPUT.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: answer == null ? '' : JSON.stringify(answer), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update a question template
     * 
     * @param id The id of the template
     * @param questionTemplateResource The question template resource object
     */
    public updateQuestionTemplateUsingPUTWithHttpInfo(id: string, questionTemplateResource?: models.QuestionTemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/templates/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionTemplateUsingPUT.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: questionTemplateResource == null ? '' : JSON.stringify(questionTemplateResource), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update a question
     * 
     * @param id The id of the question
     * @param question The updated question
     */
    public updateQuestionUsingPUTWithHttpInfo(id: string, question?: models.QuestionResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/questions/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateQuestionUsingPUT.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: question == null ? '' : JSON.stringify(question), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an import job
     * Changes should be made before process is started for there to be any effect.
     * @param id The id of the job
     * @param request The updated job
     */
    public updateUsingPUTWithHttpInfo(id: number, request?: models.ImportJobResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + `/trivia/import/${id}`;

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUsingPUT.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (knetik_oauth) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: request == null ? '' : JSON.stringify(request), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
