/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';

/* tslint:disable:no-unused-variable member-ordering */


@Injectable()
export class UsersInventoryApi {
    protected basePath = 'https://sandbox.knetikcloud.com';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    public addItemToUserInventory(id: number, userInventoryAddRequest?: models.UserInventoryAddRequest, extraHttpRequestParams?: any): Observable<models.InvoiceResource> {
        return this.addItemToUserInventoryWithHttpInfo(id, userInventoryAddRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    public checkUserEntitlementItem(userId: string, itemId: number, sku?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.checkUserEntitlementItemWithHttpInfo(userId, itemId, sku, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an entitlement item
     * 
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public createEntitlementItem(cascade?: boolean, entitlementItem?: models.EntitlementItem, extraHttpRequestParams?: any): Observable<models.EntitlementItem> {
        return this.createEntitlementItemWithHttpInfo(cascade, entitlementItem, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    public createEntitlementTemplate(template?: models.ItemTemplateResource, extraHttpRequestParams?: any): Observable<models.ItemTemplateResource> {
        return this.createEntitlementTemplateWithHttpInfo(template, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Delete an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public deleteEntitlementItem(entitlementId: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteEntitlementItemWithHttpInfo(entitlementId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteEntitlementTemplate(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteEntitlementTemplateWithHttpInfo(id, cascade, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get a single entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public getEntitlementItem(entitlementId: number, extraHttpRequestParams?: any): Observable<models.EntitlementItem> {
        return this.getEntitlementItemWithHttpInfo(entitlementId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List and search entitlement items
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementItems(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<models.PageResourceEntitlementItem> {
        return this.getEntitlementItemsWithHttpInfo(size, page, order, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get a single entitlement template
     * 
     * @param id The id of the template
     */
    public getEntitlementTemplate(id: string, extraHttpRequestParams?: any): Observable<models.ItemTemplateResource> {
        return this.getEntitlementTemplateWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List and search entitlement templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementTemplates(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<models.PageResourceItemTemplateResource> {
        return this.getEntitlementTemplatesWithHttpInfo(size, page, order, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List the user inventory entries for a given user
     * 
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUserInventories(id: number, inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string, extraHttpRequestParams?: any): Observable<models.PageResourceUserInventoryResource> {
        return this.getUserInventoriesWithHttpInfo(id, inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Get an inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    public getUserInventory(userId: number, id: number, extraHttpRequestParams?: any): Observable<models.UserInventoryResource> {
        return this.getUserInventoryWithHttpInfo(userId, id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List the log entries for this inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserInventoryLog(userId: string, id: number, size?: number, page?: number, extraHttpRequestParams?: any): Observable<models.PageResourceUserItemLogResource> {
        return this.getUserInventoryLogWithHttpInfo(userId, id, size, page, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * List the user inventory entries for all users
     * 
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUsersInventory(inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string, extraHttpRequestParams?: any): Observable<models.PageResourceUserInventoryResource> {
        return this.getUsersInventoryWithHttpInfo(inactive, size, page, filterItemName, filterItemId, filterUsername, filterGroup, filterDate, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Grant an entitlement
     * 
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    public grantUserEntitlement(userId: number, grantRequest: models.EntitlementGrantRequest, extraHttpRequestParams?: any): Observable<{}> {
        return this.grantUserEntitlementWithHttpInfo(userId, grantRequest, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public updateEntitlementItem(entitlementId: number, cascade?: boolean, entitlementItem?: models.EntitlementItem, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateEntitlementItemWithHttpInfo(entitlementId, cascade, entitlementItem, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Update an entitlement template
     * 
     * @param id The id of the template
     * @param template The updated template
     */
    public updateEntitlementTemplate(id: string, template?: models.ItemTemplateResource, extraHttpRequestParams?: any): Observable<models.ItemTemplateResource> {
        return this.updateEntitlementTemplateWithHttpInfo(id, template, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Set the behavior data for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    public updateUserInventoryBehaviorData(userId: number, id: number, data?: any, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUserInventoryBehaviorDataWithHttpInfo(userId, id, data, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    public updateUserInventoryExpires(userId: number, id: number, timestamp?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUserInventoryExpiresWithHttpInfo(userId, id, timestamp, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Set the status for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    public updateUserInventoryStatus(userId: number, id: number, inventoryStatus?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUserInventoryStatusWithHttpInfo(userId, id, inventoryStatus, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }

    /**
     * Use an item
     * 
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    public useUserEntitlementItem(userId: string, itemId: number, sku?: string, info?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.useUserEntitlementItemWithHttpInfo(userId, itemId, sku, info, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json();
                }
            });
    }


    /**
     * Adds an item to the user inventory
     * The inventory is fulfilled asynchronously UNLESS the invoice is explicitely skipped. Depending on the use case, it might require the client to verify that the entitlement was added after the fact or configure a BRE rule to get a notification in real time
     * @param id The id of the user
     * @param userInventoryAddRequest The user inventory add request object
     */
    public addItemToUserInventoryWithHttpInfo(id: number, userInventoryAddRequest?: models.UserInventoryAddRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${id}/inventory'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling addItemToUserInventory.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: userInventoryAddRequest == null ? '' : JSON.stringify(userInventoryAddRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Check for access to an item without consuming
     * Useful for pre-check and accounts for all various buisness rules
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     */
    public checkUserEntitlementItemWithHttpInfo(userId: string, itemId: number, sku?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/entitlements/${item_id}/check'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'item_id' + '}', String(itemId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling checkUserEntitlementItem.');
        }
        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling checkUserEntitlementItem.');
        }
        if (sku !== undefined) {
                    queryParameters.set('sku', <any>sku);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an entitlement item
     * 
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public createEntitlementItemWithHttpInfo(cascade?: boolean, entitlementItem?: models.EntitlementItem, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (cascade !== undefined) {
                    queryParameters.set('cascade', <any>cascade);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: entitlementItem == null ? '' : JSON.stringify(entitlementItem), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an entitlement template
     * Entitlement templates define a type of entitlement and the properties they have
     * @param template The entitlement template to be created
     */
    public createEntitlementTemplateWithHttpInfo(template?: models.ItemTemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/templates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: template == null ? '' : JSON.stringify(template), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public deleteEntitlementItemWithHttpInfo(entitlementId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/${entitlement_id}'
                    .replace('${' + 'entitlement_id' + '}', String(entitlementId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling deleteEntitlementItem.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete an entitlement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteEntitlementTemplateWithHttpInfo(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteEntitlementTemplate.');
        }
        if (cascade !== undefined) {
                    queryParameters.set('cascade', <any>cascade);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single entitlement item
     * 
     * @param entitlementId The id of the entitlement
     */
    public getEntitlementItemWithHttpInfo(entitlementId: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/${entitlement_id}'
                    .replace('${' + 'entitlement_id' + '}', String(entitlementId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling getEntitlementItem.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search entitlement items
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementItemsWithHttpInfo(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (size !== undefined) {
                    queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
                    queryParameters.set('page', <any>page);
        }

        if (order !== undefined) {
                    queryParameters.set('order', <any>order);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single entitlement template
     * 
     * @param id The id of the template
     */
    public getEntitlementTemplateWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEntitlementTemplate.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search entitlement templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getEntitlementTemplatesWithHttpInfo(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/templates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (size !== undefined) {
                    queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
                    queryParameters.set('page', <any>page);
        }

        if (order !== undefined) {
                    queryParameters.set('order', <any>order);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List the user inventory entries for a given user
     * 
     * @param id The id of the user
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUserInventoriesWithHttpInfo(id: number, inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${id}/inventory'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventories.');
        }
        if (inactive !== undefined) {
                    queryParameters.set('inactive', <any>inactive);
        }

        if (size !== undefined) {
                    queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
                    queryParameters.set('page', <any>page);
        }

        if (filterItemName !== undefined) {
                    queryParameters.set('filter_item_name', <any>filterItemName);
        }

        if (filterItemId !== undefined) {
                    queryParameters.set('filter_item_id', <any>filterItemId);
        }

        if (filterUsername !== undefined) {
                    queryParameters.set('filter_username', <any>filterUsername);
        }

        if (filterGroup !== undefined) {
                    queryParameters.set('filter_group', <any>filterGroup);
        }

        if (filterDate !== undefined) {
                    queryParameters.set('filter_date', <any>filterDate);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get an inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     */
    public getUserInventoryWithHttpInfo(userId: number, id: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/inventory/${id}'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventory.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventory.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List the log entries for this inventory entry
     * 
     * @param userId The id of the inventory owner or &#39;me&#39; for the logged in user
     * @param id The id of the user inventory
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserInventoryLogWithHttpInfo(userId: string, id: number, size?: number, page?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/inventory/${id}/log'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserInventoryLog.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getUserInventoryLog.');
        }
        if (size !== undefined) {
                    queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
                    queryParameters.set('page', <any>page);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List the user inventory entries for all users
     * 
     * @param inactive If true, accepts inactive user inventories
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param filterItemName Filter by items whose name starts with a string
     * @param filterItemId Filter by item id
     * @param filterUsername Filter by entries owned by the user with the specified username
     * @param filterGroup Filter by entries owned by the users in a given group, by unique name
     * @param filterDate A comma separated string without spaces.  First value is the operator to search on, second value is the log start date, a unix timestamp in seconds. Can be repeated for a range, eg: GT,123,LT,456  Allowed operators: (GT, LT, EQ, GOE, LOE).
     */
    public getUsersInventoryWithHttpInfo(inactive?: boolean, size?: number, page?: number, filterItemName?: string, filterItemId?: number, filterUsername?: string, filterGroup?: string, filterDate?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/inventories';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (inactive !== undefined) {
                    queryParameters.set('inactive', <any>inactive);
        }

        if (size !== undefined) {
                    queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
                    queryParameters.set('page', <any>page);
        }

        if (filterItemName !== undefined) {
                    queryParameters.set('filter_item_name', <any>filterItemName);
        }

        if (filterItemId !== undefined) {
                    queryParameters.set('filter_item_id', <any>filterItemId);
        }

        if (filterUsername !== undefined) {
                    queryParameters.set('filter_username', <any>filterUsername);
        }

        if (filterGroup !== undefined) {
                    queryParameters.set('filter_group', <any>filterGroup);
        }

        if (filterDate !== undefined) {
                    queryParameters.set('filter_date', <any>filterDate);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Grant an entitlement
     * 
     * @param userId The id of the user to grant the entitlement to
     * @param grantRequest grantRequest
     */
    public grantUserEntitlementWithHttpInfo(userId: number, grantRequest: models.EntitlementGrantRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/entitlements'
                    .replace('${' + 'user_id' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling grantUserEntitlement.');
        }
        // verify required parameter 'grantRequest' is not null or undefined
        if (grantRequest === null || grantRequest === undefined) {
            throw new Error('Required parameter grantRequest was null or undefined when calling grantUserEntitlement.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: grantRequest == null ? '' : JSON.stringify(grantRequest), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an entitlement item
     * 
     * @param entitlementId The id of the entitlement
     * @param cascade Whether to cascade group changes, such as in the limited gettable behavior. A 400 error will return otherwise if the group is already in use with different values.
     * @param entitlementItem The entitlement item object
     */
    public updateEntitlementItemWithHttpInfo(entitlementId: number, cascade?: boolean, entitlementItem?: models.EntitlementItem, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/${entitlement_id}'
                    .replace('${' + 'entitlement_id' + '}', String(entitlementId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'entitlementId' is not null or undefined
        if (entitlementId === null || entitlementId === undefined) {
            throw new Error('Required parameter entitlementId was null or undefined when calling updateEntitlementItem.');
        }
        if (cascade !== undefined) {
                    queryParameters.set('cascade', <any>cascade);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: entitlementItem == null ? '' : JSON.stringify(entitlementItem), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an entitlement template
     * 
     * @param id The id of the template
     * @param template The updated template
     */
    public updateEntitlementTemplateWithHttpInfo(id: string, template?: models.ItemTemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/entitlements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateEntitlementTemplate.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: template == null ? '' : JSON.stringify(template), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Set the behavior data for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param data The data map
     */
    public updateUserInventoryBehaviorDataWithHttpInfo(userId: number, id: number, data?: any, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/inventory/${id}/behavior-data'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryBehaviorData.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryBehaviorData.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: data == null ? '' : JSON.stringify(data), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Set the expiration date
     * Will change the current grace period for a subscription but not the bill date (possibly even ending before having the chance to re-bill)
     * @param userId user_id
     * @param id The id of the user inventory
     * @param timestamp The new expiration date as a unix timestamp in seconds. May be null (no body).
     */
    public updateUserInventoryExpiresWithHttpInfo(userId: number, id: number, timestamp?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/inventory/${id}/expires'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryExpires.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryExpires.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: timestamp == null ? '' : JSON.stringify(timestamp), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Set the status for an inventory entry
     * 
     * @param userId The id of the user
     * @param id The id of the user inventory
     * @param inventoryStatus The inventory status object
     */
    public updateUserInventoryStatusWithHttpInfo(userId: number, id: number, inventoryStatus?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/inventory/${id}/status'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling updateUserInventoryStatus.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUserInventoryStatus.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: inventoryStatus == null ? '' : JSON.stringify(inventoryStatus), // https://github.com/angular/angular/issues/10612
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Use an item
     * 
     * @param userId The id of the user to check for or &#39;me&#39; for logged in user
     * @param itemId The id of the item
     * @param sku The specific sku of an entitlement_list addition to check entitlement for. This is of very limited and specific use and should generally be left out
     * @param info Any additional info to add to the log about this use
     */
    public useUserEntitlementItemWithHttpInfo(userId: string, itemId: number, sku?: string, info?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/entitlements/${item_id}/use'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'item_id' + '}', String(itemId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling useUserEntitlementItem.');
        }
        // verify required parameter 'itemId' is not null or undefined
        if (itemId === null || itemId === undefined) {
            throw new Error('Required parameter itemId was null or undefined when calling useUserEntitlementItem.');
        }
        if (sku !== undefined) {
                    queryParameters.set('sku', <any>sku);
        }

        if (info !== undefined) {
                    queryParameters.set('info', <any>info);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters
        });

        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
