/**
 * Knetik Platform API Documentation latest 
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class GamificationAchievementsApi {

    protected basePath = 'https://sandbox.knetikcloud.com';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user's achievement status must manually be updated via the API.
     * @summary Create a new achievement definition
     * @param achievement The achievement definition
     */
    public createAchievement(achievement?: models.AchievementDefinitionResource, extraHttpRequestParams?: any): Observable<models.AchievementDefinitionResource> {
        return this.createAchievementWithHttpInfo(achievement, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Achievement templates define a type of achievement and the properties they have
     * @summary Create an achievement template
     * @param template The achievement template to be created
     */
    public createAchievementTemplate(template?: models.TemplateResource, extraHttpRequestParams?: any): Observable<models.TemplateResource> {
        return this.createAchievementTemplateWithHttpInfo(template, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Will also disable the associated generated rule, if any.
     * @summary Delete an achievement definition
     * @param name The name of the achievement
     */
    public deleteAchievement(name: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteAchievementWithHttpInfo(name, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * If cascade = 'detach', it will force delete the template even if it's attached to other objects
     * @summary Delete an achievement template
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteAchievementTemplate(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteAchievementTemplateWithHttpInfo(id, cascade, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Get a single achievement definition
     * @param name The name of the achievement
     */
    public getAchievement(name: string, extraHttpRequestParams?: any): Observable<models.AchievementDefinitionResource> {
        return this.getAchievementWithHttpInfo(name, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Get a single achievement template
     * @param id The id of the template
     */
    public getAchievementTemplate(id: string, extraHttpRequestParams?: any): Observable<models.TemplateResource> {
        return this.getAchievementTemplateWithHttpInfo(id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary List and search achievement templates
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAchievementTemplates(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<models.PageResourceTemplateResource> {
        return this.getAchievementTemplatesWithHttpInfo(size, page, order, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Get the list of triggers that can be used to trigger an achievement progress update
     */
    public getAchievementTriggers(extraHttpRequestParams?: any): Observable<Array<models.BreTriggerResource>> {
        return this.getAchievementTriggersWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Get all achievement definitions in the system
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    public getAchievements(filterTagset?: string, filterName?: string, filterHidden?: boolean, size?: number, page?: number, order?: string, filterDerived?: boolean, extraHttpRequestParams?: any): Observable<models.PageResourceAchievementDefinitionResource> {
        return this.getAchievementsWithHttpInfo(filterTagset, filterName, filterHidden, size, page, order, filterDerived, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Used by other services that depend on achievements
     * @summary Get a list of derived achievements
     * @param name The name of the derived achievement
     */
    public getDerivedAchievements(name: string, extraHttpRequestParams?: any): Observable<Array<models.AchievementDefinitionResource>> {
        return this.getDerivedAchievementsWithHttpInfo(name, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on a given achievement for a given user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    public getUserAchievementProgress(userId: number, achievementName: string, extraHttpRequestParams?: any): Observable<models.UserAchievementGroupResource> {
        return this.getUserAchievementProgressWithHttpInfo(userId, achievementName, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Assets will not be filled in on the resources returned. Use 'Get a single poll' to retrieve the full resource with assets for a given item as needed.
     * @summary Retrieve progress on achievements for a given user
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserAchievementsProgress(userId: number, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<models.PageResourceUserAchievementGroupResource> {
        return this.getUserAchievementsProgressWithHttpInfo(userId, filterAchievementDerived, filterAchievementTagset, filterAchievementName, size, page, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on a given achievement for all users
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementProgress(achievementName: string, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<models.PageResourceUserAchievementGroupResource> {
        return this.getUsersAchievementProgressWithHttpInfo(achievementName, filterAchievementDerived, filterAchievementTagset, filterAchievementName, size, page, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Assets will not be filled in on the resources returned. Use 'Get single achievement progress for user' to retrieve the full resource with assets for a given user as needed.
     * @summary Retrieve progress on achievements for all users
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementsProgress(filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<models.PageResourceUserAchievementGroupResource> {
        return this.getUsersAchievementsProgressWithHttpInfo(filterAchievementDerived, filterAchievementTagset, filterAchievementName, size, page, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Increment an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    public incrementAchievementProgress(userId: number, achievementName: string, progress?: number, extraHttpRequestParams?: any): Observable<models.UserAchievementGroupResource> {
        return this.incrementAchievementProgressWithHttpInfo(userId, achievementName, progress, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement's max_value it will be marked as earned and a BRE event will be triggered for the <code>BreAchievementEarnedTrigger</code>.
     * @summary Set an achievement progress record for a user
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    public setAchievementProgress(userId: number, achievementName: string, progress?: number, extraHttpRequestParams?: any): Observable<models.UserAchievementGroupResource> {
        return this.setAchievementProgressWithHttpInfo(userId, achievementName, progress, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @summary Update an achievement definition
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    public updateAchievement(name: string, achievement?: models.AchievementDefinitionResource, extraHttpRequestParams?: any): Observable<models.AchievementDefinitionResource> {
        return this.updateAchievementWithHttpInfo(name, achievement, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * @summary Update an achievement template
     * @param id The id of the template
     * @param template The updated template
     */
    public updateAchievementTemplate(id: string, template?: models.TemplateResource, extraHttpRequestParams?: any): Observable<models.TemplateResource> {
        return this.updateAchievementTemplateWithHttpInfo(id, template, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Create a new achievement definition
     * If the definition contains a trigger event name, a BRE rule is created, so that tracking logic is executed when the triggering event occurs. If no trigger event name is specified, the user&#39;s achievement status must manually be updated via the API.
     * @param achievement The achievement definition
     */
    public createAchievementWithHttpInfo(achievement?: models.AchievementDefinitionResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: achievement == null ? '' : JSON.stringify(achievement), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an achievement template
     * Achievement templates define a type of achievement and the properties they have
     * @param template The achievement template to be created
     */
    public createAchievementTemplateWithHttpInfo(template?: models.TemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/templates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: template == null ? '' : JSON.stringify(template), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete an achievement definition
     * Will also disable the associated generated rule, if any.
     * @param name The name of the achievement
     */
    public deleteAchievementWithHttpInfo(name: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/${name}'
                    .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling deleteAchievement.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Delete an achievement template
     * If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
     * @param id The id of the template
     * @param cascade The value needed to delete used templates
     */
    public deleteAchievementTemplateWithHttpInfo(id: string, cascade?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAchievementTemplate.');
        }
        if (cascade !== undefined) {
            queryParameters.set('cascade', <any>cascade);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single achievement definition
     * 
     * @param name The name of the achievement
     */
    public getAchievementWithHttpInfo(name: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/${name}'
                    .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAchievement.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a single achievement template
     * 
     * @param id The id of the template
     */
    public getAchievementTemplateWithHttpInfo(id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAchievementTemplate.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List and search achievement templates
     * 
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     */
    public getAchievementTemplatesWithHttpInfo(size?: number, page?: number, order?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/templates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
            queryParameters.set('page', <any>page);
        }

        if (order !== undefined) {
            queryParameters.set('order', <any>order);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get the list of triggers that can be used to trigger an achievement progress update
     * 
     */
    public getAchievementTriggersWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/triggers';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get all achievement definitions in the system
     * 
     * @param filterTagset Filter for achievements with specified tags (separated by comma)
     * @param filterName Filter for achievements whose name contains a string
     * @param filterHidden Filter for achievements that are hidden or not
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     * @param order A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC]
     * @param filterDerived Filter for achievements that are derived from other services
     */
    public getAchievementsWithHttpInfo(filterTagset?: string, filterName?: string, filterHidden?: boolean, size?: number, page?: number, order?: string, filterDerived?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterTagset !== undefined) {
            queryParameters.set('filter_tagset', <any>filterTagset);
        }

        if (filterName !== undefined) {
            queryParameters.set('filter_name', <any>filterName);
        }

        if (filterHidden !== undefined) {
            queryParameters.set('filter_hidden', <any>filterHidden);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
            queryParameters.set('page', <any>page);
        }

        if (order !== undefined) {
            queryParameters.set('order', <any>order);
        }

        if (filterDerived !== undefined) {
            queryParameters.set('filter_derived', <any>filterDerived);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a list of derived achievements
     * Used by other services that depend on achievements
     * @param name The name of the derived achievement
     */
    public getDerivedAchievementsWithHttpInfo(name: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/derived/${name}'
                    .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getDerivedAchievements.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieve progress on a given achievement for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     */
    public getUserAchievementProgressWithHttpInfo(userId: number, achievementName: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/achievements/${achievement_name}'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'achievement_name' + '}', String(achievementName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementProgress.');
        }
        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUserAchievementProgress.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieve progress on achievements for a given user
     * Assets will not be filled in on the resources returned. Use &#39;Get a single poll&#39; to retrieve the full resource with assets for a given item as needed.
     * @param userId The user&#39;s id
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUserAchievementsProgressWithHttpInfo(userId: number, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/achievements'
                    .replace('${' + 'user_id' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling getUserAchievementsProgress.');
        }
        if (filterAchievementDerived !== undefined) {
            queryParameters.set('filter_achievement_derived', <any>filterAchievementDerived);
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters.set('filter_achievement_tagset', <any>filterAchievementTagset);
        }

        if (filterAchievementName !== undefined) {
            queryParameters.set('filter_achievement_name', <any>filterAchievementName);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
            queryParameters.set('page', <any>page);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieve progress on a given achievement for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param achievementName The achievement&#39;s name
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementProgressWithHttpInfo(achievementName: string, filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/achievements/${achievement_name}'
                    .replace('${' + 'achievement_name' + '}', String(achievementName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling getUsersAchievementProgress.');
        }
        if (filterAchievementDerived !== undefined) {
            queryParameters.set('filter_achievement_derived', <any>filterAchievementDerived);
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters.set('filter_achievement_tagset', <any>filterAchievementTagset);
        }

        if (filterAchievementName !== undefined) {
            queryParameters.set('filter_achievement_name', <any>filterAchievementName);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
            queryParameters.set('page', <any>page);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieve progress on achievements for all users
     * Assets will not be filled in on the resources returned. Use &#39;Get single achievement progress for user&#39; to retrieve the full resource with assets for a given user as needed.
     * @param filterAchievementDerived Filter for achievements that are derived from other services
     * @param filterAchievementTagset Filter for achievements with specified tags (separated by comma)
     * @param filterAchievementName Filter for achievements whose name contains a string
     * @param size The number of objects returned per page
     * @param page The number of the page returned, starting with 1
     */
    public getUsersAchievementsProgressWithHttpInfo(filterAchievementDerived?: boolean, filterAchievementTagset?: string, filterAchievementName?: string, size?: number, page?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/achievements';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        if (filterAchievementDerived !== undefined) {
            queryParameters.set('filter_achievement_derived', <any>filterAchievementDerived);
        }

        if (filterAchievementTagset !== undefined) {
            queryParameters.set('filter_achievement_tagset', <any>filterAchievementTagset);
        }

        if (filterAchievementName !== undefined) {
            queryParameters.set('filter_achievement_name', <any>filterAchievementName);
        }

        if (size !== undefined) {
            queryParameters.set('size', <any>size);
        }

        if (page !== undefined) {
            queryParameters.set('page', <any>page);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Increment an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and the provided value added to the existing progress. May be negative. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The amount to add to the progress value
     */
    public incrementAchievementProgressWithHttpInfo(userId: number, achievementName: string, progress?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/achievements/${achievement_name}/progress'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'achievement_name' + '}', String(achievementName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling incrementAchievementProgress.');
        }
        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling incrementAchievementProgress.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: progress == null ? '' : JSON.stringify(progress), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Set an achievement progress record for a user
     * If no progress record yet exists for the user, it will be created. Otherwise it will be updated and progress set to the provided value. If progress meets or exceeds the achievement&#39;s max_value it will be marked as earned and a BRE event will be triggered for the &lt;code&gt;BreAchievementEarnedTrigger&lt;/code&gt;.
     * @param userId The user&#39;s id
     * @param achievementName The achievement&#39;s name
     * @param progress The new progress value
     */
    public setAchievementProgressWithHttpInfo(userId: number, achievementName: string, progress?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/${user_id}/achievements/${achievement_name}/progress'
                    .replace('${' + 'user_id' + '}', String(userId))
                    .replace('${' + 'achievement_name' + '}', String(achievementName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling setAchievementProgress.');
        }
        // verify required parameter 'achievementName' is not null or undefined
        if (achievementName === null || achievementName === undefined) {
            throw new Error('Required parameter achievementName was null or undefined when calling setAchievementProgress.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: progress == null ? '' : JSON.stringify(progress), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an achievement definition
     * The existing generated rule, if any, will be deleted. A new rule will be created if a trigger event name is specified in the new version.
     * @param name The name of the achievement
     * @param achievement The achievement definition
     */
    public updateAchievementWithHttpInfo(name: string, achievement?: models.AchievementDefinitionResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/${name}'
                    .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateAchievement.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: achievement == null ? '' : JSON.stringify(achievement), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an achievement template
     * 
     * @param id The id of the template
     * @param template The updated template
     */
    public updateAchievementTemplateWithHttpInfo(id: string, template?: models.TemplateResource, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/achievements/templates/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateAchievementTemplate.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
            'application/json'
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        // authentication (OAuth2) required
        // oauth required
        if (this.configuration.accessToken) {
            let accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers.set('Authorization', 'Bearer ' + accessToken);
        }

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: template == null ? '' : JSON.stringify(template), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
